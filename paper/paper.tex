\documentclass{article}
\usepackage[UKenglish]{babel}
\usepackage[UKenglish]{isodate}
\usepackage[utf8]{inputenc}
\usepackage{fullpage}
\usepackage[ruled,vlined]{algorithm2e}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}

\newtheorem{constraint}{Constraint}
\theoremstyle{definition}
\newtheorem{definition}{Definition}

\newcommand{\variable}[1]{\texttt{\textup{#1}}}
\newcommand{\predicates}{\mathcal{P}}
\newcommand{\variables}{\mathcal{V}}
\newcommand{\constants}{\mathcal{C}}
\newcommand{\tokens}{\mathcal{T}}
\newcommand{\arities}{\mathcal{A}}
\newcommand{\maxArity}{\textsc{max\_arity}}
\newcommand{\maxNumNodes}{\textsc{max\_num\_nodes}}
\newcommand{\maxNumClauses}{\textsc{max\_num\_clauses}}

\author{Paulius Dilkas}
\title{Generating Random Logic Programs Using Constraint Programming}

\begin{document}
\maketitle

\section{Introduction}

Motivation:
\begin{itemize}
\item Generating random programs that generate random data.
  %For example, enforcing that the decision is independent of gender.
\item Learning: how this can be used for (targeted) learning, when (atomic)
  probabilities can be assigned based on counting and we can have extra
  constraints. A more primitive angle: generate structures, learn weights.
\end{itemize}

We will often use $\Box$ as a special domain value to indicate some kind of
exception.

\section{TODO}

\begin{itemize}
\item Make negative cycle detection use the graph representation.
\item Show that the set of all ProbLog programs is equal to the set of programs
  I can generate (alternatively, show that, given any ProbLog program, there are
  parameter values high enough to generate it).
\item Given fixed parameters, use combinatorial arguments to calculate how many
  different programs there are and check that I'm generating the same number.
\item Formal definition (here and in the predicate invention paper): two
  predicates are independent if all of their groundings are independent.
\item Describe: entailment checking for cycles and negative cycles.
\item A constraint for logical equivalence.
\item Rename everything into something more appropriate.
\end{itemize}

Both determined $\implies$ fail(). Both determined but at least is one masked by
a (probable/determined) mask $\implies$ nothing. One determined $\implies$ the
other one cannot exist.

\section{Parameters}

Parameters:
\begin{itemize}
\item maximum number of solutions
\item \maxNumNodes{} (in the tree representation of a clause)
\item \maxNumClauses{}
\item option to forbid all cycles or just negative cycles
\item a list of probabilities that are randomly assigned to clauses: $\{ 0.1,
  0.2, \dots, 0.9, 1, 1, 1, 1, 1, 1 \}$.
\item a list of predicates $\predicates{}$,
\item a list of their arities $\arities{}$,
  \begin{itemize}
  \item $\maxArity{} = \max \arities{}$.
  \end{itemize}
\item a list of variables $\variables{}$,
\item and a list of constants $\constants{}$.
\end{itemize}

We also define $\tokens{} = \{ \neg, \land, \lor, \top \}$.

Decision variables:
% TODO: specify the decision variables inside clauses and their heads
\begin{itemize}
\item \variable{Body[] bodiesOfClauses}
\item \variable{Head[] headsOfClauses}: a list of length \maxNumClauses{}
\end{itemize}

\section{General Constraints}

\begin{constraint}[Each predicate gets at least one clause]
  Let $P = \{ h.\variable{predicate} \mid h \in \variable{clauseHeads} \}$. Then
  \[
    \variable{nValues}(P) =
    \begin{cases}
      \variable{numPredicates} + 1 & \text{if } \variable{count}(\Box, P) > 0 \\
      \variable{numPredicates} & \text{otherwise.}
    \end{cases}
  \]
\end{constraint}

\begin{constraint}
  Let $\prec$ be any total order defined over bodies of clauses, and let
  $\preceq$ be its extension with equality (in the same way as $\le$ extends
  $<$).
  \[
    \variable{headsOfClauses}[i-1].\variable{predicate} =
    \variable{headsOfClauses}[i].\variable{predicate} \implies
    \variable{bodiesOfClauses}[i-1] \preceq \variable{bodiesOfClauses}[i].
  \]
\end{constraint}
For example, $\preceq$ can be implemented as \variable{lexLessEq} over the
decision variables of each body.
% TODO: might need to include clause heads as well.

\section{Atoms}

\begin{definition}
  An \emph{atom} is a $\variable{predicate} \in \tokens{} \cup \predicates{}$ and a
  list of \variable{arguments} of length \maxArity{} in $\variables{} \cup
  \constants{} \cup \{ \Box \}$, where $\Box$ means the position is either
  reserved for a variable, or disabled. The atom's \variable{arity} is a number
  in $[0, \maxArity{}]$ defined by a \variable{table} constraint,
  according to the \variable{predicate}.
\end{definition}

\begin{constraint}
  For $i = 0, \dots, \maxArity{} - 1$,
  \[
    i \ge \variable{arity} \implies \variable{arguments}[i] = 0.
  \]
\end{constraint}

\section{Bodies of Clauses}

\begin{definition}
  The body of a clause is defined by:
  \begin{itemize}
  \item \variable{treeStructure}: list of length \maxNumNodes{} with
    domain $[0, \maxNumNodes{}]$.
    \begin{itemize}
    \item $\variable{treeStructure}[i] = i$: the $i$-th node is a root.
    \item $\variable{treeStructure}[i] = j$: the $i$-th node's parent is node $j$.
    \end{itemize}
  \item \variable{treeValues}: \maxNumNodes{} atoms.
  \end{itemize}
\end{definition}
% TODO: examples

Auxiliary variables: $\variable{numNodes}, \variable{numTrees} \in \{ 1, \dots,
\maxNumNodes{} \}$.

\subsection{Constraints}

\begin{constraint}
  \variable{treeStructure} represents \variable{numTrees} trees.
\end{constraint}

\begin{constraint}
  $\variable{treeStructure}[0] = 0$.
\end{constraint}

\begin{constraint}
  $\variable{numTrees} + \variable{numNodes} = \maxNumNodes{} + 1$.
\end{constraint}

\begin{constraint}
  \variable{treeStructure} is sorted.
\end{constraint}

\begin{constraint}
  For $i = 0, \dots, \maxNumNodes{} - 1$, if $\variable{numNodes} \le
  i$, then
  \[
    \variable{treeStructure}[i] = i \quad \text{and} \quad
    \variable{treeValues}[i].\variable{predicate} = \top,
  \]
  else
  \[
    \variable{treeStructure}[i] < \variable{numNodes}.
  \]
\end{constraint}

\begin{constraint}
  For $i = 0, \dots, \maxNumNodes{} - 1$,
  \begin{itemize}
  \item has 0 children $\iff$ $\variable{treeValues}[i].\variable{predicate} \in
    \predicates{}$;
  \item has 1 child $\iff$ $\variable{treeValues}[i].\variable{predicate} = \neg$;
  \item has $>1$ child $\iff$ $\variable{treeValues}[i].\variable{predicate} \in
    \{ \land, \lor \}$.
  \end{itemize}
\end{constraint}

\begin{constraint}
  For $i = 0, \dots, \maxNumNodes{} - 1$,
  \[
    \variable{treeStructure}[i] \ne i \implies
    \variable{treeValues}[i].\variable{predicate} \ne \top.
  \]
\end{constraint}

If the clause should be disabled, $\variable{numNodes} = 1$ and
$\variable{treeValues}[0].\variable{predicate} = \top$.

\begin{constraint}
  Adjacency matrix representation:
  \begin{align*}
    A[i][j] = 0 \iff &\nexists k: \variable{headsOfClauses}[k].\variable{predicate} = j \text{ and } \\
    &i \in \{ a.\variable{predicate} \mid a \in \variable{bodiesOfClauses}[k].\variable{treeValues} \}.
  \end{align*}
\end{constraint}

\section{Head of a Clause}

\begin{definition} % TODO: variables are always ordered, constants are not.
  The \emph{head} of a clause is defined by two lists:
  \begin{itemize}
  \item $\variable{predicate} \in \predicates \cup \{ \Box \}$, where $\Box$
    denotes a disabled clause.
  \item \variable{variables} of length $|\variables{}|$ and with domain
    $[0, \maxArity{}]$: how many times each variable appears in the head atom.
  \item \variable{constants} of length $\maxArity{}$ and with domain
    $\constants{} \cup \{ \Box \}$, where $\Box$ denotes that the position is
    reserved for a variable.
  \end{itemize}
  We also define the predicate's \variable{arity} using the same
  \variable{table} constraint.
\end{definition}

\begin{constraint}
  For each variable $v \in \variable{variables}$, $v \le \variable{arity}$.
\end{constraint}

\begin{constraint}
  For $i = 0, \dots, \maxArity{} - 1$,
  \[
    i \ge \variable{arity} \implies \variable{constants}[i] = 0.
  \]
\end{constraint}

\begin{constraint}[Connecting the two lists]
  $\sum_{v \in \variable{variables}} v = \variable{count}(\Box,
  \variable{constants}) + \variable{arity} - \maxArity{}$.
\end{constraint}

In \variable{variables}, all zeros must go after all non-zeros. For example,
if we have to pick one variable out of two, we must pick the first one.
\begin{constraint}
  For $i = 0, \dots, |\variables{}| - 2$, and $j = i + 1, \dots,
  |\variables{}| - 1$,
  \[
    \variable{variables}[i] \ne 0 \quad \text{or} \quad \variable{variables}[j]
    = 0.
  \]
\end{constraint}

\section{The Independence Constraint}

A dependency is an algebraic data type that is either determined (in which case
it holds only the index of the predicate) or undetermined (in which case it also
holds the indices of the source and target vertices, corresponding to the edge
responsible for making the dependency undetermined).

Propagation for independence:
\begin{itemize}
\item Two types of dependencies: determined and
  one-undetermined-edge-away-from-being-determined.
\item Look up the dependencies of both predicates. For each pair of
  matching dependencies:
  \begin{itemize}
  \item If both are determined, fail.
  \item If one is determined, the selected edge of the other must not
    exist.
  \end{itemize}
\end{itemize}

\begin{algorithm}
  \SetKwFunction{getDependencies}{getDependencies}
  \SetKwFunction{isDetermined}{isDetermined}
  \SetKwFunction{fail}{fail}
  \SetKwFunction{removeValue}{removeValue}
  \SetKwData{predicate}{predicate}
  \SetKwData{source}{source}
  \SetKwData{target}{target}
  \KwData{predicates $p_1$, $p_2$; adjacency matrix $\mathbf{A}$}
  \For{$(d_1, d_2) \in \getDependencies{$p_1$} \times
    \getDependencies{$p_2$}$ s.t. $d_1.\predicate = d_2.\predicate$}{
    \If{$d_1$.\isDetermined{} {\bf and} $d_2$.\isDetermined{}}{
      \fail{}\;
    }
    \uIf{$d_1$.\isDetermined{}}{
      $\mathbf{A}[d_2.\source][d_2.\target]$.\removeValue{$1$}\;
    }
    \ElseIf{$d_2$.\isDetermined{}}{
      $\mathbf{A}[d_1.\source][d_1.\target]$.\removeValue{$1$}\;
    }
  }
  \caption{Propagation}
\end{algorithm}

\begin{algorithm}
  \SetKwFunction{getDependencies}{getDependencies}
  \SetKwFunction{isDetermined}{isDetermined}
  \SetKwData{predicate}{predicate}
  \KwData{predicates $p_1$, $p_2$}
  $D \gets \{ (d_1, d_2) \in \getDependencies{$p_1$} \times
  \getDependencies{$p_2$} \mid d_1.\predicate = d_2.\predicate \}$\;
  \If{$\{ (d_1, d_2) \in D \mid d_1.\isDetermined{}, d_2.\isDetermined{} \} \ne
    \emptyset$}{
    \Return{FALSE}\;
  }
  \If{$D = \emptyset$}{
    \Return{TRUE}\;
  }
  \Return{UNDEFINED}\;
  \caption{Entailment}
\end{algorithm}

\begin{algorithm}
  \SetKwData{edgeExists}{edgeExists}
  \SetKwData{predicate}{predicate}
  \SetKwData{source}{source}
  \SetKwData{target}{target}
  \SetKwFunction{isDetermined}{isDetermined}
  \SetKwFunction{getDependencies}{getDependencies}
  \SetKwProg{Fn}{Function}{:}{}
  \KwData{an $n \times n$ adjacency matrix $\mathbf{A}$}
  \Fn{\getDependencies{$p$}} {
    $D \gets \{ p \}$\;
    \Repeat{$D' = D$}{
      $D' \gets D$\;
      \For{$d \in D$}{
        \For{$i \gets 1$ \KwTo $n$}{
          $\edgeExists \gets \mathbf{A}[i][d.\predicate] = \{ 1 \}$\;
          \uIf{$\edgeExists$ {\bf and} $d$.\isDetermined{}}{
            $D' \gets D' \cup \{ i \}$\;
          }
          \uElseIf{$\edgeExists$ {\bf and not} $d$.\isDetermined{}}{
            $D' \gets D' \cup \{ (i, d.\source, d.\target) \}$\;
          }
          \ElseIf{$|\mathbf{A}[i][d.\predicate]| > 1$ {\bf and} $d$.\isDetermined{}}{
            $D' \gets D' \cup \{ (i, i, d.\predicate) \}$\;
          }
        }
      }
    }
    \Return{$D$}\;
  }
  \caption{Computing the dependencies of a predicate}
\end{algorithm}

% \section{Conditional Independence}

% Finish the propagation algorithm for conditional independence. The
%  propagation algorithm for independence is extended with masks that are either
%  potential or definite. Masking happens in two stages: first, we mask
%  expressions within formulas, and then predicates. Masking algorithm uses an
%  algorithm for perfect bipartite matching.

% \begin{algorithm}
%   \SetKwProg{Fn}{Function}{:}{}
%   \SetKwFunction{potentialRoots}{potentialRoots}
%   \SetKwFunction{getTreeValues}{getTreeValues}
%   \SetKwFunction{getTreeStructureDomainValues}{getTreeStructureDomainValues}
%   \SetKwData{clause}{clause}
%   \KwData{connective $c$, a set of predicates $P$}
%   \Fn{\potentialRoots{\clause, $i$}} {
%     $R \gets \emptyset$\;
%     $V \gets \clause.\getTreeValues{$i$}$\;
%     \For{$v \in V$}{
%       \uIf{$v = c$}{
%         $R \gets R \cup \{ (i, |V| = 1) \}$\;
%       }
%       \ElseIf{$v \in P$}{
%         $R' \gets \clause.\getTreeStructureDomainValues{$i$}$\;
%         $R \gets R \cup \{ (r, |R'| = 1) \mid r \in R' \}$\;
%       }
%     }
%     \Return{$R$}\;
%   }
%   \caption{Potential root nodes of the required expression, assuming that the
%     node at index $i$ is part of the expression}
% \end{algorithm}

\end{document}