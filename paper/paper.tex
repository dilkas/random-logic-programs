\documentclass{article}
\usepackage[UKenglish]{babel}
\usepackage[UKenglish]{isodate}
\usepackage[utf8]{inputenc}
\usepackage{fullpage}
\usepackage[ruled,vlined]{algorithm2e}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}

\newtheorem{constraint}{Constraint}
\theoremstyle{definition}
\newtheorem{definition}{Definition}


\newcommand{\variable}[1]{\texttt{\textup{#1}}}

\author{Paulius Dilkas}
\title{Using Constraint Programming to Generate Random Logic Programs}

\begin{document}
\maketitle

\section{Introduction}

Motivation:
\begin{itemize}
\item Generating random programs that generate random data.
  %For example, enforcing that the decision is independent of gender.
\item Learning: how this can be used for (targeted) learning, when (atomic)
  probabilities can be assigned based on counting and we can have extra
  constraints. A more primitive angle: generate structures, learn weights.
\item Describe how the trees work with many examples.
\item Have a 'Constraint' environment.
\end{itemize}

\section{TODO}

\begin{itemize}
\item Support for constants and multiple variables.
  \begin{itemize}
  \item Each clause is defined for each predicate with standard variable names
    (X, Y, etc.).
  \item There is a list of constants and a list of predicates with their
    arities. Maybe also a list of variables.
  \end{itemize}
\item Make negative cycle detection use the graph representation.
\item Finish the propagation algorithm for conditional independence. The
  propagation algorithm for independence is extended with masks that are either
  potential or definite. Masking happens in two stages: first, we mask
  expressions within formulas, and then predicates. Masking algorithm uses an
  algorithm for perfect bipartite matching.
\item Show that the set of all ProbLog programs is equal to the set of programs
  I can generate (alternatively, show that, given any ProbLog program, there are
  parameter values high enough to generate it).
\item Given fixed parameters, use combinatorial arguments to calculate how many
  different programs there are and check that I'm generating the same number.
\item Formal definition (here and in the predicate invention paper): two
  predicates are independent if all of their groundings are independent.
\item Describe: entailment checking for cycles and negative cycles.
\end{itemize}

Both determined $\implies$ fail(). Both determined but at least is one masked by
a (probable/determined) mask $\implies$ nothing. One determined $\implies$ the
other one cannot exist.

\section{Parameters}

Parameters:
\begin{itemize}
\item maximum number of solutions
\item \variable{maxNumNodes} (in the tree representation of a clause)
\item list of predicates with their variables
\item maximum number of clauses
\item option to forbid all cycles or just negative cycles
\item list of probabilities that are randomly assigned to clauses: $\{ 0.1,
  0.2, \dots, 0.9, 1, 1, 1, 1, 1, 1 \}$
\end{itemize}

Decision variables: % TODO: rename these things
% TODO: specify the decision variables inside clauses and their heads
\begin{itemize}
\item \variable{IntVar[] clauseAssignments}: a predicate or disabled
\item \variable{Clause[] clauses}
\item \variable{Head[] clauseHeads}
\end{itemize}

\section{General Constraints}

\begin{constraint}[Each predicate gets at least one clause]
  \variable{numDisabledClauses} is defined by a \variable{count} constraint.
  \[
    \variable{numDistinctValues} =
    \begin{cases}
      \variable{numPredicates} + 1 & \text{if } \variable{numDisabledValues} > 0 \\
      \variable{numPredicates} & \text{otherwise}
    \end{cases}
  \]
  (also constrained using the \variable{nValues} constraint).
\end{constraint}

\begin{constraint}[\variable{clauseAssignments} are sorted]
  \[
    \variable{clauseAssignments}[i-1] = \variable{clauseAssignments}[i] \implies
    \variable{clause}[i-1] \preceq \variable{clause}[i].
  \]
\end{constraint}

\section{Bodies of Clauses}

\begin{definition}
  The body of a clause is defined by:
  \begin{itemize}
  \item \variable{IntVar[] treeStructure}
    \begin{itemize}
    \item $\texttt{treeStructure}[i] = i$: the $i$-th node is a root.
    \item $\texttt{treeStructure}[i] = j$: the $i$-th node's parent is node $j$.
    \end{itemize}
  \item \variable{IntVar[] treeValues}: $\neg$, $\land$, $\lor$, $\top$, and any
    predefined predicates with variables.
  \end{itemize}
\end{definition}
% TODO: examples
% TODO: update the info on treeValues

Auxiliary variables: $\variable{numNodes}, \variable{numTrees} \in \{ 1, \dots,
\variable{maxNumNodes} \}$.

\subsection{Constraints}

\begin{constraint}
  \variable{treeStructure} represents \variable{numTrees} trees.
\end{constraint}

\begin{constraint}
  $\variable{treeStructure}[0] = 0$.
\end{constraint}

\begin{constraint}
  $\variable{numTrees} + \variable{numNodes} = \variable{maxNumNodes} + 1$.
\end{constraint}

\begin{constraint}
  \variable{treeStructure} is sorted.
\end{constraint}

\begin{constraint}
  For $i = 0, \dots, \variable{maxNumNodes} - 1$, if $\variable{numNodes} \le
  i$, then
  \[
    \variable{treeStructure}[i] = i \quad \text{and} \quad
    \variable{treeValues}[i] = \top,
  \]
  else
  \[
    \variable{treeStructure}[i] < \variable{numNodes}.
  \]
\end{constraint}

\begin{constraint}
  For $i = 0, \dots, \variable{maxNumNodes} - 1$,
  \begin{itemize}
  \item has 0 children $\iff$ $\variable{treeValues}[i]$ is a predicate;
  \item has 1 child $\iff$ $\variable{treeValues}[i] = \neg$;
  \item has $>1$ child $\iff$ $\variable{treeValues}[i] \in \{ \land, \lor \}$.
  \end{itemize}
\end{constraint}

\begin{constraint}
  For $i = 0, \dots, \variable{maxNumNodes} - 1$,
  \[
    \variable{treeStructure}[i] \ne i \implies \variable{treeValues}[i] \ne
    \top.
  \]
\end{constraint}

If the clause should be disabled, $\variable{numNodes} = 1$ and
$\variable{treeValues}[0] = \top$.

\begin{constraint}
  Adjacency matrix representation:
  \[
    A[i][j] = 0 \iff \nexists k: \variable{clauseAssignments}[k] = j \text{ and }
    i \in \variable{clauses}[k].\variable{treeValues}
  \]
\end{constraint}

\section{The Independence Constraint}

A dependency is an algebraic data type that is either determined (in which case
it holds only the index of the predicate) or undetermined (in which case it also
holds the indices of the source and target vertices, corresponding to the edge
responsible for making the dependency undetermined).

Propagation for independence:
\begin{itemize}
\item Two types of dependencies: determined and
  one-undetermined-edge-away-from-being-determined.
\item Look up the dependencies of both predicates. For each pair of
  matching dependencies:
  \begin{itemize}
  \item If both are determined, fail.
  \item If one is determined, the selected edge of the other must not
    exist.
  \end{itemize}
\end{itemize}

\begin{algorithm}
  \SetKwFunction{getDependencies}{getDependencies}
  \SetKwFunction{isDetermined}{isDetermined}
  \SetKwFunction{fail}{fail}
  \SetKwFunction{removeValue}{removeValue}
  \SetKwData{predicate}{predicate}
  \SetKwData{source}{source}
  \SetKwData{target}{target}
  \KwData{predicates $p_1$, $p_2$; adjacency matrix $\mathbf{A}$}
  \For{$(d_1, d_2) \in \getDependencies{$p_1$} \times
    \getDependencies{$p_2$}$ s.t. $d_1.\predicate = d_2.\predicate$}{
    \If{$d_1$.\isDetermined{} {\bf and} $d_2$.\isDetermined{}}{
      \fail{}\;
    }
    \uIf{$d_1$.\isDetermined{}}{
      $\mathbf{A}[d_2.\source][d_2.\target]$.\removeValue{$1$}\;
    }
    \ElseIf{$d_2$.\isDetermined{}}{
      $\mathbf{A}[d_1.\source][d_1.\target]$.\removeValue{$1$}\;
    }
  }
  \caption{Propagation}
\end{algorithm}

\begin{algorithm}
  \SetKwFunction{getDependencies}{getDependencies}
  \SetKwFunction{isDetermined}{isDetermined}
  \SetKwData{predicate}{predicate}
  \KwData{predicates $p_1$, $p_2$}
  $D \gets \{ (d_1, d_2) \in \getDependencies{$p_1$} \times
  \getDependencies{$p_2$} \mid d_1.\predicate = d_2.\predicate \}$\;
  \If{$\{ (d_1, d_2) \in D \mid d_1.\isDetermined{}, d_2.\isDetermined{} \} \ne
    \emptyset$}{
    \Return{FALSE}\;
  }
  \If{$D = \emptyset$}{
    \Return{TRUE}\;
  }
  \Return{UNDEFINED}\;
  \caption{Entailment}
\end{algorithm}

\begin{algorithm}
  \SetKwData{edgeExists}{edgeExists}
  \SetKwData{predicate}{predicate}
  \SetKwData{source}{source}
  \SetKwData{target}{target}
  \SetKwFunction{isDetermined}{isDetermined}
  \SetKwFunction{getDependencies}{getDependencies}
  \SetKwProg{Fn}{Function}{:}{}
  \KwData{an $n \times n$ adjacency matrix $\mathbf{A}$}
  \Fn{\getDependencies{$p$}} {
    $D \gets \{ p \}$\;
    \Repeat{$D' = D$}{
      $D' \gets D$\;
      \For{$d \in D$}{
        \For{$i \gets 1$ \KwTo $n$}{
          $\edgeExists \gets \mathbf{A}[i][d.\predicate] = \{ 1 \}$\;
          \uIf{$\edgeExists$ {\bf and} $d$.\isDetermined{}}{
            $D' \gets D' \cup \{ i \}$\;
          }
          \uElseIf{$\edgeExists$ {\bf and not} $d$.\isDetermined{}}{
            $D' \gets D' \cup \{ (i, d.\source, d.\target) \}$\;
          }
          \ElseIf{$|\mathbf{A}[i][d.\predicate]| > 1$ {\bf and} $d$.\isDetermined{}}{
            $D' \gets D' \cup \{ (i, i, d.\predicate) \}$\;
          }
        }
      }
    }
    \Return{$D$}\;
  }
  \caption{Computing the dependencies of a predicate}
\end{algorithm}

% \section{Conditional Independence}

% \begin{algorithm}
%   \SetKwProg{Fn}{Function}{:}{}
%   \SetKwFunction{potentialRoots}{potentialRoots}
%   \SetKwFunction{getTreeValues}{getTreeValues}
%   \SetKwFunction{getTreeStructureDomainValues}{getTreeStructureDomainValues}
%   \SetKwData{clause}{clause}
%   \KwData{connective $c$, a set of predicates $P$}
%   \Fn{\potentialRoots{\clause, $i$}} {
%     $R \gets \emptyset$\;
%     $V \gets \clause.\getTreeValues{$i$}$\;
%     \For{$v \in V$}{
%       \uIf{$v = c$}{
%         $R \gets R \cup \{ (i, |V| = 1) \}$\;
%       }
%       \ElseIf{$v \in P$}{
%         $R' \gets \clause.\getTreeStructureDomainValues{$i$}$\;
%         $R \gets R \cup \{ (r, |R'| = 1) \mid r \in R' \}$\;
%       }
%     }
%     \Return{$R$}\;
%   }
%   \caption{Potential root nodes of the required expression, assuming that the
%     node at index $i$ is part of the expression}
% \end{algorithm}

\end{document}