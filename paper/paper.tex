\documentclass[runningheads]{llncs}
\usepackage{graphicx}
%\usepackage[UKenglish]{babel}
%\usepackage[UKenglish]{isodate}
%\usepackage[utf8]{inputenc}
\usepackage[ruled,vlined]{algorithm2e}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage[capitalise]{cleveref}

\newtheorem{constraint}{Constraint}

\newcommand{\variable}[1]{\texttt{\textup{#1}}}
\newcommand{\predicates}{\mathcal{P}}
\newcommand{\variables}{\mathcal{V}}
\newcommand{\constants}{\mathcal{C}}
\newcommand{\tokens}{\mathcal{T}}
\newcommand{\arities}{\mathcal{A}}
\newcommand{\maxArity}{\mathcal{M}_{\mathcal{A}}}
\newcommand{\maxNumNodes}{\mathcal{M}_{\mathcal{N}}}
\newcommand{\maxNumClauses}{\mathcal{M}_{\mathcal{C}}}

\begin{document}

\title{Generating Random Logic Programs Using Constraint Programming}
\author{Paulius Dilkas\orcidID{0000-1111-2222-3333}}
\authorrunning{P. Dilkas}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.

\institute{University of Edinburgh, Edinburgh, UK\\
\email{p.dilkas@sms.ed.ac.uk}}
\maketitle

\begin{abstract}
The abstract should briefly summarize the contents of the paper in
150--250 words.

\keywords{Constraint Programming \and Logic Programming \and Probabilistic Logic
  Programming.}
\end{abstract}

\section{Introduction}

Motivation:
\begin{itemize}
\item Generating random programs that generate random data.
  %For example, enforcing that the decision is independent of gender.
\item Learning: how this can be used for (targeted) learning, when (atomic)
  probabilities can be assigned based on counting and we can have extra
  constraints. A more primitive angle: generate structures, learn weights.
\end{itemize}

We will often use $\Box$ as a special domain value to indicate some kind of
exception. We also use Choco \cite{choco}. This works with both Prolog
\cite{DBLP:books/daglib/0041598} and ProbLog \cite{DBLP:conf/ijcai/RaedtKT07}.
Tested with SWI-Prolog \cite{DBLP:journals/tplp/WielemakerSTL12}.

Inference options to explore. Logspace vs normal space. Symbolic vs
non-symbolic. Propagate evidence (might be irrelevant)? Propagate weights?
Supported knowledge compilation techniques: sdd, sddx, bdd, nnf, ddnnf, kbest,
fsdd, fbdd.

\section{TODO}

\begin{itemize}
\item Given fixed parameters, use combinatorial arguments to calculate how many
  different programs there are and check that I'm generating the same number.
\item Formal definition (here and in the predicate invention paper): two
  predicates are independent if all of their groundings are independent.
\item A constraint for logical equivalence.
\item Show that the set of all ProbLog programs is equal to the set of programs
  I can generate (alternatively, show that, given any ProbLog program, there are
  parameter values high enough to generate it).
\item Perhaps negative cycle detection could use the same graph as the
  independence propagator? If we extend each domain to {-1, 0, 1}, but that
  might make propagation weaker or slower.
\end{itemize}

\section{Parameters}

Parameters:
\begin{itemize}
\item maximum number of solutions,
\item $\maxNumNodes{}$: maximum number of nodes in the tree representation of a
  clause,
\item $\maxNumClauses{}$: maximum number of clauses in a program,
\item option to forbid all cycles or just negative cycles,
\item a list of probabilities that are randomly assigned to clauses,
\item a list of predicates $\predicates{}$,
\item a list of their arities $\arities{}$,
  \begin{itemize}
  \item maximum arity $\maxArity{} \coloneqq \max \arities{}$.
  \end{itemize}
\item a list of variables $\variables{}$,
\item and a list of constants $\constants{}$.
\end{itemize}

We also define $\tokens{} = \{ \neg, \land, \lor, \top \}$. All decision
variables of the model are contained in two arrays of length $\maxNumClauses{}$:
\begin{itemize}
\item \variable{Body[] bodiesOfClauses}
\item \variable{Head[] headsOfClauses}
\end{itemize}

\section{General Constraints}

\begin{constraint}
  For $i = 0, \dots, \maxNumClauses - 1$, let $p_i =
  \variable{headsOfClauses}[i].\variable{predicate}$. Then
  \[
    \variable{sort}((p_i)_{i=0}^{\maxNumClauses - 1}, (p_i)_{i=0}^{\maxNumClauses
      - 1}),
  \]
  i.e., all clauses describing the same predicate are listed together and
  sorted.
\end{constraint}

\begin{constraint}
  Each predicate gets at least one clause. Let $P = \{ h.\variable{predicate}
  \mid h \in \variable{clauseHeads} \}$. Then
  \[
    \variable{nValues}(P) =
    \begin{cases}
      \variable{numPredicates} + 1 & \text{if } \variable{count}(\Box, P) > 0 \\
      \variable{numPredicates} & \text{otherwise.}
    \end{cases}
  \]
\end{constraint}

\begin{constraint}
  Let $\prec$ be any total order defined over bodies of clauses, and let
  $\preceq$ be its extension with equality (in the same way as $\le$ extends
  $<$). If
  \[
    \variable{headsOfClauses}[i-1].\variable{predicate} =
    \variable{headsOfClauses}[i].\variable{predicate},
  \]
  then $\variable{bodiesOfClauses}[i-1] \preceq \variable{bodiesOfClauses}[i]$.
\end{constraint}
For example, $\preceq$ can be implemented as \variable{lexLessEq} over the
decision variables of each body.
% TODO: might need to include clause heads as well.

\section{Atoms} % TODO: rename to 'nodes'

%, where $\Box$ means the position is either
%  reserved for a variable, or disabled

\begin{definition} \label{def:atom}
  An \emph{atom} is a $\variable{predicate} \in \tokens{} \cup \predicates{}$
  and a list of \variable{arguments} of length $\maxArity{}$ in $\variables{}
  \cup \constants{}$. The atom's \variable{arity} is a number in $[0,
  \maxArity{}]$ defined by a \variable{table} constraint, according to the
  \variable{predicate}.
\end{definition}

\begin{constraint}
  For $i = 0, \dots, \maxArity{} - 1$,
  \[
    i \ge \variable{arity} \implies \variable{arguments}[i] = 0.
  \]
\end{constraint}

\section{Bodies of Clauses}

\begin{definition}
  The body of a clause is defined by:
  \begin{itemize}
  \item \variable{treeStructure}: list of length $\maxNumNodes{}$ with
    domain $[0, \maxNumNodes{} - 1]$.
    \begin{itemize}
    \item $\variable{treeStructure}[i] = i$: the $i$-th node is a root.
    \item $\variable{treeStructure}[i] = j$: the $i$-th node's parent is node $j$.
    \end{itemize}
  \item \variable{treeValues}: $\maxNumNodes{}$ atoms.
  \end{itemize}
\end{definition}
% TODO: examples

Auxiliary variables: $\variable{numNodes}, \variable{numTrees} \in \{ 1, \dots,
\maxNumNodes{} \}$.

\subsection{Constraints}

\begin{constraint}
  $\variable{tree}(\variable{treeStructure}, \variable{numTrees})$, i.e.,
  \variable{treeStructure} represents \variable{numTrees} trees (dominator-based
  filtering \cite{DBLP:conf/cp/FagesL11}).
\end{constraint}

\begin{constraint}
  $\variable{treeStructure}[0] = 0$.
\end{constraint}

\begin{constraint}
  $\variable{numTrees} + \variable{numNodes} = \maxNumNodes{} + 1$.
\end{constraint}

\begin{constraint}
  $\variable{sort}(\variable{treeStructure}, \variable{treeStructure})$, i.e.,
  \variable{treeStructure} is sorted.
\end{constraint}

\begin{constraint}
  For $i = 0, \dots, \maxNumNodes{} - 1$, if $\variable{numNodes} \le
  i$, then
  \[
    \variable{treeStructure}[i] = i \quad \text{and} \quad
    \variable{treeValues}[i].\variable{predicate} = \top,
  \]
  else
  \[
    \variable{treeStructure}[i] < \variable{numNodes}.
  \]
\end{constraint}

\begin{constraint}
  For $i = 0, \dots, \maxNumNodes{} - 1$,
  \begin{itemize}
  \item has 0 children $\iff$ $\variable{treeValues}[i].\variable{predicate} \in
    \predicates{}$;
  \item has 1 child $\iff$ $\variable{treeValues}[i].\variable{predicate} = \neg$;
  \item has $>1$ child $\iff$ $\variable{treeValues}[i].\variable{predicate} \in
    \{ \land, \lor \}$.
  \end{itemize}
\end{constraint}

\begin{constraint}
  For $i = 0, \dots, \maxNumNodes{} - 1$,
  \[
    \variable{treeStructure}[i] \ne i \implies
    \variable{treeValues}[i].\variable{predicate} \ne \top.
  \]
\end{constraint}

If the clause should be disabled, $\variable{numNodes} = 1$ and
$\variable{treeValues}[0].\variable{predicate} = \top$.

\begin{constraint}
  Adjacency matrix representation:
  \begin{align*}
    A[i][j] = 0 \iff &\nexists k: \variable{headsOfClauses}[k].\variable{predicate} = j \text{ and } \\
    &i \in \{ a.\variable{predicate} \mid a \in \variable{bodiesOfClauses}[k].\variable{treeValues} \}.
  \end{align*}
\end{constraint}

\section{Head of a Clause}

Our definition of a head of a clause is more restrictive than \cref{def:atom}.

\begin{definition} % TODO: variables are always ordered, constants are not.
  The \emph{head} of a clause is defined by two lists:
  \begin{itemize}
  \item $\variable{predicate} \in \predicates \cup \{ \Box \}$, where $\Box$
    denotes a disabled clause.
  \item \variable{variables} of length $|\variables{}|$ and with domain
    $[0, \maxArity{}]$: how many times each variable appears in the head atom.
  \item \variable{constants} of length $\maxArity{}$ and with domain
    $\constants{} \cup \{ \Box \}$, where $\Box$ denotes that the position is
    reserved for a variable.
  \end{itemize}
  We also define the predicate's \variable{arity} using the same
  \variable{table} constraint.
\end{definition}

\begin{constraint}
  For each $v \in \variable{variables}$, $v \le \variable{arity}$.
\end{constraint}

\begin{constraint}
  For $i = 0, \dots, \maxArity{} - 1$,
  \[
    i \ge \variable{arity} \implies \variable{constants}[i] = 0.
  \]
\end{constraint}

\begin{constraint}
  Connecting the two lists:
  \[
    \sum_{v \in \variable{variables}} v = \variable{count}(\Box,
    \variable{constants}) + \variable{arity} - \maxArity{}.
  \]
\end{constraint}

In \variable{variables}, all zeros must go after all non-zeros. For example,
if we have to pick one variable out of two, we must pick the first one.
\begin{constraint}
  For $i = 0, \dots, |\variables{}| - 2$, and $j = i + 1, \dots,
  |\variables{}| - 1$,
  \[
    \variable{variables}[i] \ne 0 \quad \text{or} \quad \variable{variables}[j]
    = 0.
  \]
\end{constraint}

\section{Counting Programs}

Let $p_a$ be the number of predicates in $\predicates{}$ with arity $a \in
\arities{}$.

Number of atoms:
\[
  A = \sum_{a \in \arities{}} p_a(|\variables{}| + |\constants{}|)^a
\]

Number of clauses:
\[
  C = 1 + \sum_{n=1}^{\maxNumNodes{}} T(n),
\]
where $T(n)$ is defined recursively as:
\[
  T(1) = A
\]
and
\[
  T(n) = T(n-1) + 2\sum_{\substack{\text{ordered partitions}\\
      c_1 + \dots + c_k = n - 1,\\
      k \ge 2}} \prod_{i=1}^k T(c_i).
\]

Example of ordered partitions:
\[
  3 = 2 + 1 = 2 + 1 = 1 + 1 + 1,
\]
so for $n=4$, the sum would have three terms.

Number of heads for a specific predicate with arity $a \in \arities{}$:
\[
  H_a = \sum_{v=1}^a \binom{a}{v} |\constants{}|^{a-v}
  \sum_{k=0}^{|\variables{}|-1} \binom{v-1}{k}.
\]
First, select the $v$ positions dedicated for variables. The remaining $a-v$
constants can then be filled in $|\constants{}|^{a-v}$ ways. Filling $v$
positions with $k+1$ variables in a non-decreasing manner (without skipping any
variables) can be seen as putting $k$ `bars' in the $v-1$ spaces between $v$
positions. Each bar represents switching to the next variable.
% TODO: the equation is not always defined

Number of programs:
\[
  \left( C^{|\predicates{}|} \prod_{\mathsf{P}/a \in \predicates{}} H_a \right)
  \left( \sum_{n=0}^{\maxNumClauses{} - |\predicates{}|} \left( C
    \sum_{a \in \arities{}} p_aH_a \right)^n \right)
\]
The first half of the equation represents setting up a single clause for every
predicate, i.e., we select its body and its head. The second half iterates over
the number of clauses that could be added. For each of the $n$ additional
clauses, we choose its body and its head (defined by a predicate and its arity).

Parameters that affect this:
\begin{itemize}
\item $\arities{}$ and $(p_a)_{a \in \arities{}}$. Consider even zero arity.
\item $|\predicates{}| = \sum_{a \in \arities{}} p_a$
\item $|\variables{}|$
\item $|\constants{}|$. Consider no variables and no constants.
\item $\maxNumNodes{} \ge 1$
\item $\maxNumClauses{} \ge |\predicates{}|$
\end{itemize}
% TODO: this is without any kind of cycle detection and without probabilities

\section{The Independence Constraint}

A dependency is an algebraic data type that is either determined (in which case
it holds only the index of the predicate) or undetermined (in which case it also
holds the indices of the source and target vertices, corresponding to the edge
responsible for making the dependency undetermined).

Propagation for independence:
\begin{itemize}
\item Two types of dependencies: determined and
  one-undetermined-edge-away-from-being-determined.
\item Look up the dependencies of both predicates. For each pair of
  matching dependencies:
  \begin{itemize}
  \item If both are determined, fail.
  \item If one is determined, the selected edge of the other must not
    exist.
  \end{itemize}
\end{itemize}

\begin{algorithm}
  \SetKwFunction{getDependencies}{getDependencies}
  \SetKwFunction{isDetermined}{isDetermined}
  \SetKwFunction{fail}{fail}
  \SetKwFunction{removeValue}{removeValue}
  \SetKwData{predicate}{predicate}
  \SetKwData{source}{source}
  \SetKwData{target}{target}
  \KwData{predicates $p_1$, $p_2$; adjacency matrix $\mathbf{A}$}
  \For{$(d_1, d_2) \in \getDependencies{$p_1$} \times
    \getDependencies{$p_2$}$ s.t. $d_1.\predicate = d_2.\predicate$}{
    \If{$d_1$.\isDetermined{} {\bf and} $d_2$.\isDetermined{}}{
      \fail{}\;
    }
    \uIf{$d_1$.\isDetermined{}}{
      $\mathbf{A}[d_2.\source][d_2.\target]$.\removeValue{$1$}\;
    }
    \ElseIf{$d_2$.\isDetermined{}}{
      $\mathbf{A}[d_1.\source][d_1.\target]$.\removeValue{$1$}\;
    }
  }
  \caption{Propagation}
\end{algorithm}

\begin{algorithm}
  \SetKwFunction{getDependencies}{getDependencies}
  \SetKwFunction{isDetermined}{isDetermined}
  \SetKwData{predicate}{predicate}
  \KwData{predicates $p_1$, $p_2$}
  $D \gets \{ (d_1, d_2) \in \getDependencies{$p_1$} \times
  \getDependencies{$p_2$} \mid d_1.\predicate = d_2.\predicate \}$\;
  \If{$\{ (d_1, d_2) \in D \mid d_1.\isDetermined{}, d_2.\isDetermined{} \} \ne
    \emptyset$}{
    \Return{FALSE}\;
  }
  \If{$D = \emptyset$}{
    \Return{TRUE}\;
  }
  \Return{UNDEFINED}\;
  \caption{Entailment}
\end{algorithm}

\begin{algorithm}
  \SetKwData{edgeExists}{edgeExists}
  \SetKwData{predicate}{predicate}
  \SetKwData{source}{source}
  \SetKwData{target}{target}
  \SetKwFunction{isDetermined}{isDetermined}
  \SetKwFunction{getDependencies}{getDependencies}
  \SetKwProg{Fn}{Function}{:}{}
  \KwData{an $n \times n$ adjacency matrix $\mathbf{A}$}
  \Fn{\getDependencies{$p$}} {
    $D \gets \{ p \}$\;
    \Repeat{$D' = D$}{
      $D' \gets D$\;
      \For{$d \in D$}{
        \For{$i \gets 1$ \KwTo $n$}{
          $\edgeExists \gets \mathbf{A}[i][d.\predicate] = \{ 1 \}$\;
          \uIf{$\edgeExists$ {\bf and} $d$.\isDetermined{}}{
            $D' \gets D' \cup \{ i \}$\;
          }
          \uElseIf{$\edgeExists$ {\bf and not} $d$.\isDetermined{}}{
            $D' \gets D' \cup \{ (i, d.\source, d.\target) \}$\;
          }
          \ElseIf{$|\mathbf{A}[i][d.\predicate]| > 1$ {\bf and} $d$.\isDetermined{}}{
            $D' \gets D' \cup \{ (i, i, d.\predicate) \}$\;
          }
        }
      }
    }
    \Return{$D$}\;
  }
  \caption{Computing the dependencies of a predicate}
\end{algorithm}

\section{Entailment Checking for Negative/All Cycles}

\begin{enumerate}
\item Let $C$ be a set of clauses such that their bodies and predicates in their
  heads are fully determined.
\item If $C = \emptyset$, return UNDEFINED.
\item Construct an adjacency list representation of a graph where vertices
  represent predicates. Each edge is either \emph{positive} or \emph{negative}.
  There is an edge from $p$ to $q$ if $q$ appears in the body of a predicate
  with $p$ as its head. The edge is negative if, when traversing the tree to
  reach some instance of $q$, we pass through a $\neg$ node. Otherwise, it's
  positive.
\item Run a modified cycle detection algorithm that detects all cycles that have
  at least one negative edge.
\item If we found a cycle, return FALSE.
\item If $C$ encompasses all clauses, return TRUE.
\item Return UNDEFINED.
\end{enumerate}

% \section{Conditional Independence}

% Finish the propagation algorithm for conditional independence. The
%  propagation algorithm for independence is extended with masks that are either
%  potential or definite. Masking happens in two stages: first, we mask
%  expressions within formulas, and then predicates. Masking algorithm uses an
%  algorithm for perfect bipartite matching.

% Both determined $\implies$ fail(). Both determined but at least is one masked by
% a (probable/determined) mask $\implies$ nothing. One determined $\implies$ the
% other one cannot exist.

% \begin{algorithm}
%   \SetKwProg{Fn}{Function}{:}{}
%   \SetKwFunction{potentialRoots}{potentialRoots}
%   \SetKwFunction{getTreeValues}{getTreeValues}
%   \SetKwFunction{getTreeStructureDomainValues}{getTreeStructureDomainValues}
%   \SetKwData{clause}{clause}
%   \KwData{connective $c$, a set of predicates $P$}
%   \Fn{\potentialRoots{\clause, $i$}} {
%     $R \gets \emptyset$\;
%     $V \gets \clause.\getTreeValues{$i$}$\;
%     \For{$v \in V$}{
%       \uIf{$v = c$}{
%         $R \gets R \cup \{ (i, |V| = 1) \}$\;
%       }
%       \ElseIf{$v \in P$}{
%         $R' \gets \clause.\getTreeStructureDomainValues{$i$}$\;
%         $R \gets R \cup \{ (r, |R'| = 1) \mid r \in R' \}$\;
%       }
%     }
%     \Return{$R$}\;
%   }
%   \caption{Potential root nodes of the required expression, assuming that the
%     node at index $i$ is part of the expression}
% \end{algorithm}

\section*{Acknowledgments}

The author would like to thank Vaishak Belle for his comments. This work was
supported by the EPSRC Centre for Doctoral Training in Robotics and Autonomous
Systems, funded by the UK Engineering and Physical Sciences Research Council
(grant EP/S023208/1).

\bibliographystyle{splncs04}
\bibliography{paper}

\end{document}